&ensp;&ensp;通常希望用户可以通过鼠标在上面拾取(点击)或者其他的输入设备来选择一个物体。当然，要实现这样的操作需要更多的知识。
&ensp;&ensp;如果你需要屏幕上某个点上或者是某个区域里的所有对象，并且不关心这些对象是否可见，你可能需要`CPU`拾取的方案。这种类型的拾取一般出现在建模或是`CAD`软件中。在`CPU`上使用包围体层次结构的时候它是相当有效的方案[Section 19.1.1](#)。在某个像素的位置产生一条射线，从视锥体的近平面向远平面传递。然后根据需要测试这条射线是否会与包围体结构相交，类似于在全局照明算法中为加速追踪光线所做的工作。对于用户定义在屏幕上的矩形形成的矩形区域，我们往往会创建一个平截头体而不是一条射线，然后根据层次结构对它(创建的Frustum)进行测试。
&ensp;&ensp;`CPU`上的求交测试存在一些问题，这取决于具体的拾取的要求，如果没有使用加速结构去测试一个具有上千个三角形的网格是非常昂贵的操作，比如说一个层次结构或者网格与他们本身做求交测试。如果对精度要求比较高，像通过位移贴图(`displacement mapping`)生成几何或者`GPU`细分需要`CPU`配合工作。对于需要透明度映射的对象，比如说树叶，用户不应该可以选择一个完全透明的纹素(`texels`)，在`CPU`模拟纹理的访问需要进行大量的计算，此时往往伴随着存在任何可能丢弃纹素的着色器。
&ensp;&ensp;通常我们只需要在屏幕上的某个像素或者某个区域，对于这种类型的拾取，可以使用`GPU`的渲染管道完成。这种方法由 _Hanrahan_ 和 _Haeberli_ [[664](#661)]提出。为了支持这种拾取，渲染场景时将给场景中的每个三角形、多边形或者网格对象一个唯一的标识，可以将它作为一种颜色。这种想法与可见性缓冲类似，形成类似于第[906](#)页[20.12](#)中上的图像。生成的图像被存储在外部，然后使用它完成快速拾取操作。当用户点击一个像素，得到对应的颜色标识然后立刻找到对象，这些标识符可以被渲染到单独的渲染目标，也可以使用较为简单的着色器显示它，因此它的开销是非常低的，最大的开销可能是从`GPU`读取像素到`CPU`。
&ensp;&ensp;任何像素着色器接受到或者是计算的结果都可以存储在一个离屏的目标中[<font color=red>纹理对象</font>]。例如，法线或纹理坐标常被存储作为纹理。使用这样的方式通过插值也可以找到三角形内一个点的相对位置。每个三角形都使用三角形顶点的颜色进行渲染，即红色`(255,0,0)`、绿色`(0,255,0)`和蓝色`(0,0,255)`。假设我选中的像素插值的颜色是`(23,192,40)`。这意味着红色顶点对于当前点的颜色的贡献因子是$\frac{23}{255}\quad$,绿色$\frac{192}{255}\quad$，蓝色$\frac{40}{255}\quad$。这些值同时也是重心坐标$(\frac{23}{255}\quad,\frac{192}{255}\quad,\frac{40}{255}\quad)$，我们将在接下来的[22.8.1](#)节介绍它。
&ensp;&ensp;使用`GPU`拾取最初作为三维绘图的一部分，这种拾取是非常适合这种相机和场景都不进行移动的系统，因为拾取缓冲只需要生成一次之后便可以重复使用这个缓冲。为了相机移动的时候进行拾取，另一种方法是额外渲染一次场景到一个更小的缓冲上，例如，$3\times3$使用一个离轴相机显示在屏幕的某个很小的区域。`CPU`端的视锥体剔除应该消减几乎所有的几何仅仅只是很少的像素会被着色，这种提出可以使这个过程更快速。为了拾取所有的对象(并不仅仅是可见的对象)，这种渲染到小窗口的方法可以通过深度剥离或者不渲染前一次的拾取对象从而调用多次。